[
  {
    "code": "no-compare-neg-zero",
    "docs": "Disallows comparing against negative zero (`-0`).\n\nComparing a value directly against negative may not work as expected as it will also pass for non-negative zero (i.e. `0` and `+0`). Explicit comparison with negative zero can be performed using `Object.is`.\n\n### Invalid:\n```typescript\nif (x === -0) {\n}\n```\n### Valid:\n```typescript\nif (x === 0) {\n}\n```\n```typescript\nif (Object.is(x, -0)) {\n}\n```"
  },
  {
    "code": "no-cond-assign",
    "docs": "Disallows the use of the assignment operator, `=`, in conditional statements.\n\nUse of the assignment operator within a conditional statement is often the result of mistyping the equality operator, `==`. If an assignment within a conditional statement is required then this rule allows it by wrapping the assignment in parentheses.\n\n### Valid:\n```typescript\nvar x;\nif (x === 0) {\n  var b = 1;\n}\n```\n```typescript\nfunction setHeight(someNode) {\n  do {\n    someNode.height = \"100px\";\n  } while ((someNode = someNode.parentNode));\n}\n```\n\n### Invalid:\n```typescript\nvar x;\nif (x = 0) {\n  var b = 1;\n}\n```\n```typescript\nfunction setHeight(someNode) {\n  do {\n    someNode.height = \"100px\";\n  } while (someNode = someNode.parentNode);\n}\n```"
  },
  {
    "code": "no-dupe-keys",
    "docs": "Disallows duplicate keys in object literals.\n\nSetting the same key multiple times in an object literal will override other assignments to that key and can cause unexpected behaviour.\n\n### Invalid:\n```typescript\nconst foo = {\n  bar: \"baz\",\n  bar: \"qux\"\n};\n```\n```typescript\nconst foo = {\n  \"bar\": \"baz\",\n  bar: \"qux\"\n};\n```\n```typescript\nconst foo = {\n  0x1: \"baz\",\n  1: \"qux\"\n};\n```\n### Valid:\n```typescript\nvar foo = {\n  bar: \"baz\",\n  quxx: \"qux\"\n};\n```"
  },
  {
    "code": "no-empty",
    "docs": "Disallows the use of empty block statements.\n\nEmpty block statements are legal but often represent that something was missed and can make code less readable. This rule ignores block statements that only contain comments. This rule also ignores empty constructors and function bodies (including arrow functions), which are covered by the `no-empty-function` rule.\n\n### Valid:\n```typescript\nif (foo) {\n  // empty\n}\n```\n```typescript\nwhile (foo) {\n  /* empty */\n}\n```\n```typescript\ntry {\n  doSomething();\n} catch (ex) {\n  // continue regardless of error\n}\n```\n```typescript\ntry {\n  doSomething();\n} finally {\n  /* continue regardless of error */\n}\n```\n\n### Invalid:\n```typescript\nif (foo) {\n}\n```\n```typescript\nwhile (foo) {\n}\n```\n```typescript\nswitch(foo) {\n}\n```\n```typescript\ntry {\n  doSomething();\n} catch(ex) {\n\n} finally {\n\n}\n```"
  },
  {
    "code": "no-unsafe-finally",
    "docs": "Disallows the use of control flow statements within `finally` blocks.\n\nUse of the control flow statements (`return`, `throw`, `break` and `continue`) overrides the usage of any control flow statements that might have been used in the `try` or `catch` blocks, which is usually not the desired behaviour.\n\n### Invalid:\n```typescript\nlet foo = function() {\n  try {\n    return 1;\n  } catch(err) {\n    return 2;\n  } finally {\n    return 3;\n  }\n};\n```\n```typescript\nlet foo = function() {\n  try {\n    return 1;\n  } catch(err) {\n    return 2;\n  } finally {\n    throw new Error;\n  }\n};\n```\n### Valid:\n```typescript\nlet foo = function() {\n  try {\n    return 1;\n  } catch(err) {\n    return 2;\n  } finally {\n    console.log(\"hola!\");\n  }\n};\n```"
  },
  {
    "code": "valid-typeof",
    "docs": "Restricts the use of the `typeof` operator to a specific set of string literals.\n\nWhen used with a value the `typeof` operator returns one of the following strings:\n- `\"undefined\"`\n- `\"object\"`\n- `\"boolean\"`\n- `\"number\"`\n- `\"string\"`\n- `\"function\"`\n- `\"symbol\"`\n- `\"bigint\"`\n\nThis rule disallows comparison with anything other than one of these string literals when using the `typeof` operator, as this likely represents a typing mistake in the string. The rule also disallows comparing the result of a `typeof` operation with any non-string literal value, such as `undefined`, which can represent an inadvertent use of a keyword instead of a string. This includes comparing against string variables even if they contain one of the above values as this cannot be guaranteed. An exception to this is comparing the results of two `typeof` operations as these are both guaranteed to return on of the above strings.\n\n### Invalid:\n```typescript\ntypeof foo === \"strnig\"\n```\n```typescript\ntypeof foo == \"undefimed\"\n```\n```typescript\ntypeof bar != \"nunber\"\n```\n```typescript\ntypeof bar !== \"fucntion\"\n```\n```typescript\ntypeof foo === undefined\n```\n```typescript\ntypeof bar == Object\n```\n```typescript\ntypeof baz === anotherVariable\n```\n```typescript\ntypeof foo == 5\n```\n\n### Valid:\n```typescript\ntypeof foo === \"undefined\"\n```\n```typescript\ntypeof bar == \"object\"\n```\n```typescript\ntypeof baz === \"string\"\n```\n```typescript\ntypeof bar === typeof qux\n```"
  }
]
